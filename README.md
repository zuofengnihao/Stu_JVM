# Stu_JVM

## 第一章 虚拟机介绍

* 寄存器结构 指令集简单 指令多 设计简单 执行效率较低

* 栈结构(HotSpot) 指令集多 指令简单 执行高效 耦合度高

1. 三大虚拟机商用虚拟机 oracle的HotSpot(Sun)和JRockit(Bea) ibm的J9 OpenJDK虚拟机HotSpot
2. android Dalvik虚拟机 apk 不遵循java虚拟机规范
3. 可能会替换HotSpot的虚拟机 oracle labs Graal VM 中间格式 语言：Java Scala Groovy Kotlin C C++ JavaScript Ruby Python R等
4. 其他虚拟机 taobaoVM 阿里深度优化的虚拟机 严重依赖Intel处理器 可以虚拟机间共享对象



## 第二章 类加载子系统

### 第一节 内存结构描述

#### 内存简图
ClassFile => 类加载子系统 <=> 运行时数据区(方法区 Java堆 (线程共享) | (线程独占) 程序计数器 JVM栈 本地方法栈) <=> 执行引擎 | 本地方法接口 <= 本地方法库 

### 第二节 类加载器与类的加载过程

#### 类加载子系统简图
字节码文件 => {类加载子系统: 加载阶段|引导类加载器 扩展类加载器 系统类加载器| -> 链接阶段(验证 准备 解析) -> 初始化阶段}

#### 类加载过程
开始 类如果没有装载 则加载这个类 使用相应的类加载器(ClassLoader)装载 装在过程中出现问题会抛出异常 如果这个类正常装载后 或者文件已经装载过 就会链接 初始化

1. 加载Loading：  
1.通过类的全限定名获取定义此类的二进制字节流  
2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构  
3.在内存中生成一个代表这个类的java.lang.Class对象作为方法区这个类的各种数据的访问入口  
重要：此阶段主要功能是生成类的实例 即Class对象实例

2. 链接：  
1.验证：魔术CAFEBABE   
2.准备阶段：所有static变量(常亮final static 在编译期间已经分配 在此阶段显式初始化)赋初始值 int为0 浮点为0.0 布尔false 引用null 初始化环节才完成赋值  
3.解析：将常量池内的符号引用转换为直接引用的过程

3. 初始化：执行类构造器方法clinit()过程 当类中没有static变量或者static静态代码块时是不会有clinit()方法出现的 若该类的父类有clinit() jvm
会保证该类的父类的clinit()方法已经执行 一个类的Clinit()方法在多线程下一定会被同步加锁

### 第三节 类的加载器分类

jvm支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)

将所有派生于抽象类Classloader的类加载器都划分为自定义加载器(Extension ClassLoader和System CLassLoader都属于此类)

我最常见的类加载器始终只有3个：  

1. Bootstrap Class Loader 引导类加载器：C/C++编写 不可获取 负责加载Java核心类库(jre/lib/rt.jar,resources.jar或sun.boot.class.path) 具体见图 022.png 

2. Extension Class Loader 扩展类加载器：Java编写 派生与ClassLoader 父类为引导类加载器 负责加载java.ext.dirs jre/lib/ext子目录 具体简图 023.png

3. System Class Loader 系统类加载器：Java编写 派生与ClassLoader 父类为扩展类加载器 加载java.class.path 我们程序的默认加载器 具体见图 024.png

用户自定义加载器：需求分析
1. 隔离加载类
2. 修改类的加载方式
3. 扩展加载源
4. 防止源码泄露  

实现：见026.png

### 第三节 ClassLoader的使用说明

ClassLoader 抽象类 除引导类加载器其他类加载器都继承自ClassLoader  

方法详见027.png

获取ClassLoader 详见028.png

### 第四节 双亲委派机制
当一个类加载器准备加载一个类时会先委派给父类加载器加载直至最顶层 父类加载器会尝试加载此类 如果加载不成功再由子类加载器加载直至最底层  

优点：避免类的重复加载 保护程序安全 防止核心API被随意篡改（沙箱安全机制）


### 第五节 其他内容

两个class对象是否为同一个类存在两个必要条件：
1. 类的完整类名一致(包括包名)
2. 加载这个类的ClassLoader（指ClassLoader实例对象）一致

如果一个类型是由用户类加载器加载的 JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。  

对类的使用分为主动使用与被动使用  
主动：
1. 创建类的实例（new）
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName()）
5. 初始化一个类的子类
6. JVM启动时被标明为启动类的类
7. JDK7开始提供的动态语言支持：  
   java.lang.invoke.MethodHandle实例的解析结果REF_getStatic REF_putStatic REF_invokeStatic句柄对应的类没有初始化，则初始化  

除以上7中情况 其他都是对类的被动使用 都不会导致类的初始化  


## 第三章 运行时数据区概述及线程

### 第一节 概述

详见图片 009.png  
线程共享 方法区（元空间） 堆内存  
线程独占 JVM栈 本地方法栈 程序计数器  

每个JVM只有一个Runtime实例 即运行时环境

### 第二节 线程

JVM每个线程都与操纵系统的本地线程直接映射 操作系统负责安排调度可用cpu 本地线程初始化后调用Run方法

## 第四章 程序计数器

### 第一节 PCRegister介绍

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。
它是唯一没有规定任何OutOfMemoryError情况的区域。详细见005-007.png

### 第二节 举例说明

详见代码和011.png

### 第三节 两个常见的问题

1. 使用pc寄存器存储字节码指令地址有什么用 答：线程线程间来回切换我们需要记录每个线程执行到了哪里
2. pc寄存器为什么设计为线程私有 答：因为线程间来回切换是无法预知的

## 第五章 虚拟机栈JVM Stack

### 第一节 虚拟机栈概述

详见001-016.png  
-Xss 设置线程的最大栈空间

### 第二节 栈的存储单位

栈帧：
1. 局部变量表（Local Variables）
2. 操作数栈（Operand Stack）或表达式栈
3. 动态链接（Dynamic Linking）或指向运行时常量池的方法引用
4. 方法返回地址（Return Address）或方法正常退出或异常退出的定义
5. 一些附加信息
6. 补充说明 动态链接、方法返回地址、附加信息统一为帧数据区

### 第三节 局部变量表

定义为一个数字数组 用与存储方法参数和定义在方法体内的局部变量 这些数据类型包括 基本数据类型 对象引用 returnAddress类型  
局部变量表的容量大小是在编译器就确定下来的 保存在方法的Code属性的maximum local variables数据中 运行期间不会修改局部变量表大小

局部变量表最基本的存储单元是Slot（单元槽）32位以内的类型只占用一个slot（包括returnAddress）64位的类型占用两个slot  
byte short char boolean都会被转换为int long double占两个slot  

实例方法和构造方法的局部变量表中 该对象的引用this将会存放在index为0的slot处  

在栈帧中与性能调优最密切的部分是局部变量表，方法执行时，虚拟机使用局部变量表完成方法的传递  
局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收  

### 第四节 操作数栈

Java的操作数栈使用数组实现 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。  
一个方法开始时，一个栈帧被创建出来，此时此方法的操作数栈是空的。  
操作数栈的深度也是在编译器就定义好的，保存在Code属性中，为max_stack的值。  
栈中的任何一个元素都是可以任意的Java数据类型。32bit的类型占用一个栈深度，64bit的类型占两个栈深度  
操作数栈并非采用访问索引的方式进行数据的访问，而是通过入栈(push)出栈(pop)操作来完成数据的访问。  

如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中。  
另外，Java虚拟机的解释引擎是基于栈实现的执行引擎，其中的栈就是指的操作数栈。

### 第五节 代码追踪

详见LocalVariablesTest OperandStackTest SlotTest 和图片

### 第六节 栈顶缓存技术

由于操作数栈读写操作频繁 HotSpot JVM设计者提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。

### 第七节 动态链接

每个栈帧内部都包含了一个指向运行时常量池中该栈帧所属方法的引用 目的是为了支持当前方法的代码能够实现动态链接 如invokedynamic指令  
动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。  
为什么要有常量池？常量池的作用，就是为了提供一些符号和常量，便于指令的识别。


### 第八节 方法的调用：解析与分派

将符号引用转换为调用方法的直接引用（在链接的解析阶段完成）与方法的绑定机制相关：
1. 静态链接：目标方法在编译期可知
2. 动态链接：在编译期不可知

绑定机制：绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，仅发生一次
1. 早起绑定：目标方法在编译期可知，且运行期保持不变 静态链接绑定
2. 晚期绑定：在编译期无法被确定，只能在程序运行期根据实际的类型绑定

非虚方法：
* 在编译期就确定了具体调用版本，这个版本运行时不可变的称非虚方法
* 静态方法、私有方法、final方法、构造器、父类方法都是非虚方法
* 其他方法都是虚方法

虚拟机中的方法调用指令：
* 普通调用指令：
1. invokestatic: 调用静态方法
2. invokespecial: 调用构造方法、私有方法及父类方法
3. invokevirtual: 调用所有虚方法
4. invokeinterface: 调用接口方法
* 动态调用指令： 
1. invokedynamic：动态解析出需要调用的方法，然后执行 

invokestatic指令和invokespecial指令调用的方法（invokevirtual被声明final的方法）称非虚方法，其余的称虚方法  

关于invokedynamic：是java为实现动态语言支持而做的一种改进  

动态语言与静态语言：静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型，变量值才有类型。  

方法重写的本质：详见061.png 虚方法的调用是一层层往上找的

虚方法表：
1. 为了提高性能，jvm采用在类的方法区建立一个虚方法表来实现。使用索引表来代替查找。
2. 每个类都有一个虚方法表，存放着各个方法的实际入口。
3. 虚方法表也是在链接阶段（链接的解析阶段）被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕。

### 第九节 方法的返回地址

方法返回地址：存储的是该方法的pc寄存器的值。本质上方法的退出就是当前栈帧出栈的过程，此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

一个方法的结束分两种方式：
1. 正常执行结束。正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。
2. 出现未处理的异常，非正常退出。异常退出时，返回地址是要通过异常表来确定的，栈帧中一般不保存这部分的信息。  

无论那种方式退出，在方法退出后都返回到该方法被调用的位置。但是异常退出不会有返回值。  

1. 正常退出时：执行引擎到任意一个方法返回的字节码指令（return），会有返回值传递给上一层方法调用者。返回指令包含ireturn（返回值boolean byte short char int）、lreturn、freturn、dreturn、areturn、return（void方法、实例初始化方法、类和接口的初始化方法使用）
2. 异常退出时（未处理的异常）：如果这个异常没有被处理或在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法的退出。

### 第十节 一些附加信息

栈帧中还允许携带与java虚拟机实现相关的一些附加信息，比如对程序调试提供支持的信息。

### 第十一节 栈的相关面试

1. 问：举例栈溢出的情况？  
   答： StackOverFlowError 栈空间不足，-Xss设置栈的大小。申请扩容内存时，当整个内存空间不足的时候抛出OutOfMemoryError。
2. 问：调整栈大小，就能保证不出现溢出吗？  
   答：不能。
3. 问：分配的栈内存越大越好吗？  
   答：不是。浪费空间。
4. 问：垃圾回收是否会涉及到虚拟机栈？  
   答：不会，栈的内存就是压栈出栈。
5. 问：方法中定义的局部变量是否线程安全？  
   答：具体问题具体分析。详细见chapter5.StringBuilderTest
   
## 第六章 本地方法接口

一个Native Method就是一个Java调用非Java代码的接口。该方法由非Java语言实现。作用是融合不同语言。  
native修饰符可以与其他java修饰符链接，除abstract外。  
为什么使用native method？详见005-007.png；  

### 第七章 本地方栈

用于管理本地方法的调用。