# 我读《深入理解java虚拟机》第三版

# 第一部分 走进Java

略....

# 第二部分 自动内存管理

## 第2章 Java内存区域与内存溢出异常

### 2.1 概述

略....

### 2.2 运行时数据区

#### 2.2.1 程序计数器

程序计数器(Program Counter Register)  

它可以看作当前线程所执行的字节码的行号指示器。  

为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的计数器。线程私有  

它是唯一一个没有OutOfMemoryError情况的区域

#### 2.2.2 Java虚拟机栈

Java虚拟机栈(Java Virtual Machine Stack)

也是线程私有的  

它的生命周期与线程相同  

每个方法被执行都会同步创建一个栈帧。即栈中存储的就是栈帧  

每个栈帧中有独立的 局部变量表 操作数栈 动态链接 方法出口等信息。  
局部变量表存放了编译期可知的各种 Java基本数据类型 对象引用(reference类型，可以是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与对象相关的位置) returnAddress返回地址(指向了一条字节码指令的地址)  

局部变量表的基本单位 变量槽slot 64位的long double占用两个变量槽 其余的只占用一个。局部变量表所需的内存空间在编译期已确定。  

如果线程请求栈深度大于虚拟机栈所允许的最大深度，将抛出StackOverFlowError  
如果Java虚拟机栈允许扩容但无法申请到足够内存时，将抛出OutOfMemoryError  

注意：！HotSpot虚拟机栈容量是不可以动态扩展的，所以HotSpot虚拟机不会由与虚拟机无发扩展而导致OutOfMemoryError 只要线程申请栈空间成功就不会有OOM，但是如果申请失败就仍然会出现OOM。  
理解：hotspot不会因为扩容问题出现OOM，但是线程申请栈空间失败会出现OOM，这个失败的原因肯定不是超过了最大深度，因为超过最大深度抛出的是StackOverFlow异常。

#### 2.2.3 本地方法栈

本地方法栈(Native Method Stacks)

与虚拟机栈类似，只是它执行的是本地方法而非Java方法。  

HotSpot已将虚拟机栈与本地方法栈结合

#### 2.2.4 Java堆

Java堆(Java Heap)  

Java堆在虚拟机启动时创建，被所有线程共享的最大区域，存放对象实例。  

共享的Java堆中可以划分线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)  

`-Xmx 最大堆内存 -Xms 最小堆内存(启动时的堆大小)`  

堆没有内存完成实例分配，并且无法扩展抛出OutOfMemoryError

分代收集 `Eden` `To Survivor` `From Survivor`  

#### 2.2.5 方法区

方法区(Method Area)  

与堆同样是线程共享区域  

储存 类型信息 常量 静态变量 即使编译器编译后的代码缓存。  

Jdk8以前用"永久带"实现方法区，之后用本地物理内存"元空间"实现  

如果方法区无法满足新的内存分配需求，抛出OutOfMemoryError

#### 2.2.6 运行时常量池

运行时常量池(Runtime Constant Pool)  

它是方法区的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。  

与Class文件常量池不同的是具备动态性，可以将新常量放入常量池而并非一定要预置于Class文件中，比如String类的intern()方法。  

异常同方法区，因为本就是方法区的一部分。

#### 2.2.7 直接内存

即本地物理内存，也会导致OutOfMemoryError 

JDk1.4中加入的NIO 可以使用ByteBuffer.allocateDirect()返回的DirectByteBuffer对象操作直接内存

### 2.3 HotSpot虚拟机对象探秘

#### 2.3.1 对象的创建

当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化。如果没有，先加载对应的类。加载检查通过后，将为新对象分配内存。  

如果堆中是规整的，分已使用和未使用两个区，一个指针指向临界点，分配内存仅仅是移动指针，这种方式称"指针碰撞"  
如果不规整，虚拟机必须维护一个表来记录哪些可用内存，这种分配方式是"空闲列表"  

在并发情况下并分配内存也不是线程安全的，有两种解决方案：
1. 分配内存时采用CAS配上失败重试进行同步处理
2. 使用本地线程缓冲(TLAB)，分配在缓冲区。通过 `XX: +/-UseTLAB` 参数赖设定

分配完内存后，虚拟机必须将分配到的内存空间初始化零值(不包括对象头，如果使用了TLAB会在TLAB分配时顺便进行)  

接着设置对象头，再执行<init>()方法(构造)

> cmpxchg是x86中的CAS指令 这是一个C++方法

#### 2.3.2 对象的内存布局

分为三个部分：对象头(Header) 实例数据(Instance Data) 对齐填充(Padding)

对象头：分两类信息
1. 第一类信息用与存储对象自身的运行时数据,如 哈希码 GC分带年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳。官方称为"Mark Word"。32位虚拟机中mark word占32位，64位占64位
2. 第二类信息是类型指针。此外如果是数组对象必须有一块用于记录数组长度。

实例数据：  
实例数据中包含自己与父类的实例数据，分配的顺序受 `-XX:FieldsAllocationStyle` 参数和定义的顺序影响。Hotspot默认顺序：longs/doubles ints shorts/chars bytes/booleans oops，宽度相同的总是被分配到一起。在这个条件下，父类的参数总是在子类之前，但参数 `+XX:CompactFields` 为true时(默认为ture)子类中较窄的变量也运行插入父类变量的空隙中。  

对齐填充：  
HostSpot虚拟机要求对象起始地址必须是8字节的整数倍。换句话说就是对象大小必须是8字节的整数被，不足则会填充。

#### 2.3.3 对象的访问定位

由栈上的reference类型访问对象。主流的访问方式主要有 “句柄” 和 “直接指针” 两种。  

句柄访问：
<div align="center"><img src="/image/readbook/1.png"/></div>

直接指针：
<div align="center"><img src="/image/readbook/2.png"/></div>

优缺点：句柄访问在内存频繁移动时，不需要大量修改reference地址，只要修改句柄上的对象地址，但是访问速度慢。而指针访问速度快，但对象移动时，所有指向这个对象的reference地址都需要改动。Hotspot使用的是直接指针(如果使用的Shenandoah收集器的话也会有一次额外的转发)。

### 2.4 实战OutOfMemoryError异常

#### 2.4.1 Java堆溢出

详见代码readbook.c241

> VM Args: -Xms20m(最小堆内存) -Xmx20m(最大堆内存)  
  +HeapDumpOnOutOfMemoryError(Dump内存堆快照)  

#### 2.4.2 虚拟机栈和本地方法栈溢出

> -Xoss 设置本地方栈的大小 对Hotspot没有意义  
  -Xss 设置栈容量 Hotspot栈不可扩容不能设置最大值

#### 2.4.3  方法区和运行时常量池溢出

> -XX:MaxMetaspaceSize 元空间最大容量 默认-1 即不限制 或只受限于本地内存   
  -XX:MetaspaceSize 元空间初始容量 当达到该值时就会GC 并根据需要修改容量 但不超过设置的最大值  
  -XX:MaxMetaspaceFreeRatio 调整GC后最小元空间剩余容量的百分比  
  -XX:MinMetaspaceFreeRatio 最大元空间剩余容量的百分比

在1.7之后 String常量池放在堆内存中

```java
    /**
    *  在1.6前会打印两个false 
    *  因为 StringBuild创建的String对象在堆中 str1.intern() 对象放在了方法区中
    *  而在1.7之后会打印一个true 一个false 
    *  打印true是因为 intern() 放入String常量池中 而String常量池已经移到了堆上
    *  而打印false是因为sun.misc.Version类加载时就将java放入了String常量池(堆)
    *  StringBuild创建的就是另一个对上的对象了
    */
    public class RuntimeConstantPool {
        
        public static void main(String args[]) {
            String str1 = new StringBuilder("计算机").append("软件").toString();
            System.out.println(str1.intern() == str1); // 1.6 false 1.7 true
                        
            String str1 = new StringBuilder("ja").append("va").toString();
            System.out.println(str1.intern() == str1);// 1.6 false 1.7 false
        }
        
    }
    
```
#### 2.4.4 本机直接内存溢出

> -XX:MaxDirectMemorySize 最大直接内存 默认值与java堆一致(-Xmx的值)

如果使用了DirectMemory的程序需要注意(比如NIO DirectByteBuffer)

### 2.5 本章小结

略....(请看上面的笔记)

## 第3章 垃圾收集器与内存分配策略

### 3.1 概述

略....

### 3.2 对象已死

#### 3.2.1 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。  
优缺点：实现简单，相互引用就会产生内存泄露

#### 3.2.2 可达性分析法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GCRoots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
<div align="center"><img src="/image/readbook/3.jpg"/></div>

GCRoots对象：
1. 在虚拟机栈(本地变量表)中引用的对象
2. 在方法区中类静态属性引用的对象
3. 在方法区中常量引用的对象
4. 在本地方法栈中JNI(Native方法)引用的对象
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象 一些常驻的异常对象(NullPoint,OOM),还有系统类加载器
6. 所有被同步锁(synchronized关键字)持有的对象
7. 反映Java虚拟机部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

#### 3.2.3 再谈引用

引用分为:
1. 强引用(Strongly Reference):  
   指在程序代码之中普遍存在的引用赋值，类似`Object obj = new Object()` 只要强引用关系还存在，垃圾收集器就永远不会回收。
2. 软引用(Soft Reference):  
   描述非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。JDK 1.2版之后提供了SoftReference类来实现软引用。
3. 弱引用(Weak Reference):  
   被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
4. 虚引用（PhantomReference）  
   虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。
   这4种引用强度依次逐渐减弱。

#### 3.2.4 生存还是死亡

经过可达性分析后被标记的对象并不会马上死亡，GC系统会筛选出此对象是否必要执行finalize()方法。如果对象没有重写，或已经被调用过一次(每个对象虚拟机只会调用一次finalize()方法)，虚拟机就判断不再需要执行，进入"即将回收"的集合。如果重写了没有执行过，则会进入F-Queue队列让一个低调用线程去执行(但并不保证可以直接结束)。如果在执行方法时，this对象被重新引用，对象就不会被销毁，反之则进入"即将回收"的集合。

#### 3.2.5 回收方法区

废弃的常量：  
没有任何引用，垃圾收集器判断有必要的话会被回收。  

不再使用的类型：
判定是否废弃的类型需要满足3个条件：
1. 该类所有实例(包括派生类)被回收
2. 该类的类加载器被回收
3. 该类的Class对象没有任何引用  

满足以上3个条件也仅仅是"允许被回收"

> -Xnoclasscg 参数控制是否有类回收

有大量的反射，动态代理，CGLib等字节码框架，动态生成Jsp以及OGSi这类频繁自定义类加载器的场景中需要开启。

### 3.3 垃圾回收算法

#### 3.3.1 分代收集理论

* 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
* 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
* 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
* 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
* 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

#### 3.3.2 标记-清除算法

标记需要回收的对象/不需要回收的对象，清楚被标记/未被标记的对象。  
缺点：效率不稳定，空间碎片化

#### 3.3.2 标记-复制算法

"半区复制" 即 `To Survivor` `From Survivor`  
优缺点：空间连续，浪费了一定空间，只适合存活对象不多的区域。所以用于新生代回收算法。 
Eden与Survivor 比例 8:1:1

#### 3.3.3 标记-整理算法

即在标记清除上多做一次整理，让内存空间不在有碎片。  
HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的

### 3.4 HotSpot的算法细节实现

#### 3.4.1 根节点枚举

固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中  

所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。

#### 3.4.2 安全点

HotSpot没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）。  

安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的。例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。  

如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：
1. 抢先式中断（Preemptive Suspension）：系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。
2. 主动式中断（Voluntary Suspension）：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。  
   由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。  

#### 3.4.3 安全区域

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。  

当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

#### 3.4.4 记忆集和卡表

所有涉及部分区域收集行为的垃圾收集器都会面临对象跨代引用所带来的问题。解决方案就是依靠记忆集。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

记忆集的的记录精度：
* 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
* 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
* 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式。卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的。  
  字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即512字节。
  一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

#### 3.4.5 写屏障

HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。  应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作。  

伪共享：现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。

> HotSpot虚拟机增加了一个新的参数 -XX：+UseCondCardMark ，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。

#### 3.4.6 并发的可达性分析

三色标记:
* 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
* 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
* 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。  

如果用户线程与收集器是并发工作，收集器在对象图上标记颜色，同时用户线程在修改引用关系，可能出现两种后果：
1. 把原本消亡的对象错误标记为存活。可以容忍。
2. 原本存活的对象错误标记为已消亡。非常致命。

例图：
<div align="center"><img src="/image/readbook/4.jpg"/></div>

Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题(2问题)，即原本应该是黑色的对象被误标为白色：
* 赋值器插入了一条或多条从黑色对象到白色对象的新引用。
* 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：
1. 增量更新（Incremental Update）:  
   增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，`黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了`。

2. 原始快照（Snapshot At TheBeginning，SATB）:
   原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，`无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索`。

### 3.5 经典垃圾回收器

这里讨论的是在JDK 7Update 4之后（在这个版本中正式提供了商用的G1收集器，此前G1仍处于实验状态）、JDK11正式发布之前，OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。

<div align="center"><img src="/image/readbook/5.jpg"/></div>

上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。


#### 3.5.1 Serial收集器

曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择，这个收集器是一个单线程工作的收集器。强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

#### 3.5.2 ParNew收集器


