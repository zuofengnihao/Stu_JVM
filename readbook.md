# 我读《深入理解java虚拟机》第三版

# 第一部分 走进Java

略....

# 第二部分 自动内存管理

## 第2章 Java内存区域与内存溢出异常

### 2.1 概述

略....

### 2.2 运行时数据区

#### 2.2.1 程序计数器

程序计数器(Program Counter Register)  

它可以看作当前线程所执行的字节码的行号指示器。  

为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的计数器。线程私有  

它是唯一一个没有OutOfMemoryError情况的区域

#### 2.2.2 Java虚拟机栈

Java虚拟机栈(Java Virtual Machine Stack)

也是线程私有的  

它的生命周期与线程相同  

每个方法被执行都会同步创建一个栈帧。即栈中存储的就是栈帧  

每个栈帧中有独立的 局部变量表 操作数栈 动态链接 方法出口等信息。  
局部变量表存放了编译期可知的各种 Java基本数据类型 对象引用(reference类型，可以是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与对象相关的位置) returnAddress返回地址(指向了一条字节码指令的地址)  

局部变量表的基本单位 变量槽slot 64位的long double占用两个变量槽 其余的只占用一个。局部变量表所需的内存空间在编译期已确定。  

如果线程请求栈深度大于虚拟机栈所允许的最大深度，将抛出StackOverFlowError  
如果Java虚拟机栈允许扩容但无法申请到足够内存时，将抛出OutOfMemoryError  

注意：！HotSpot虚拟机栈容量是不可以动态扩展的，所以HotSpot虚拟机不会由与虚拟机无发扩展而导致OutOfMemoryError 只要线程申请栈空间成功就不会有OOM，但是如果申请失败就仍然会出现OOM。  
理解：hotspot不会因为扩容问题出现OOM，但是线程申请栈空间失败会出现OOM，这个失败的原因肯定不是超过了最大深度，因为超过最大深度抛出的是StackOverFlow异常。

#### 2.2.3 本地方法栈

本地方法栈(Native Method Stacks)

与虚拟机栈类似，只是它执行的是本地方法而非Java方法。  

HotSpot已将虚拟机栈与本地方法栈结合

#### 2.2.4 Java堆

Java堆(Java Heap)  

Java堆在虚拟机启动时创建，被所有线程共享的最大区域，存放对象实例。  

共享的Java堆中可以划分线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)  

`-Xmx 最大堆内存 -Xms 最小堆内存(启动时的堆大小)`  

堆没有内存完成实例分配，并且无法扩展抛出OutOfMemoryError

分代收集 `Eden` `To Survivor` `From Survivor`  

#### 2.2.5 方法区

方法区(Method Area)  

与堆同样是线程共享区域  

储存 类型信息 常量 静态变量 即使编译器编译后的代码缓存。  

Jdk8以前用"永久带"实现方法区，之后用本地物理内存"元空间"实现  

如果方法区无法满足新的内存分配需求，抛出OutOfMemoryError

#### 2.2.6 运行时常量池

运行时常量池(Runtime Constant Pool)  

它是方法区的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。  

与Class文件常量池不同的是具备动态性，可以将新常量放入常量池而并非一定要预置于Class文件中，比如String类的intern()方法。  

异常同方法区，因为本就是方法区的一部分。

#### 2.2.7 直接内存

即本地物理内存，也会导致OutOfMemoryError 

JDk1.4中加入的NIO 可以使用ByteBuffer.allocateDirect()返回的DirectByteBuffer对象操作直接内存

### 2.3 HotSpot虚拟机对象探秘

#### 2.3.1 对象的创建

当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化。如果没有，先加载对应的类。加载检查通过后，将为新对象分配内存。  

如果堆中是规整的，分已使用和未使用两个区，一个指针指向临界点，分配内存仅仅是移动指针，这种方式称"指针碰撞"  
如果不规整，虚拟机必须维护一个表来记录哪些可用内存，这种分配方式是"空闲列表"  

在并发情况下并分配内存也不是线程安全的，有两种解决方案：
1. 分配内存时采用CAS配上失败重试进行同步处理
2. 使用本地线程缓冲(TLAB)，分配在缓冲区。通过 `XX: +/-UseTLAB` 参数赖设定

分配完内存后，虚拟机必须将分配到的内存空间初始化零值(不包括对象头，如果使用了TLAB会在TLAB分配时顺便进行)  

接着设置对象头，再执行<init>()方法(构造)

> cmpxchg是x86中的CAS指令 这是一个C++方法

#### 2.3.2 对象的内存布局

分为三个部分：对象头(Header) 实例数据(Instance Data) 对齐填充(Padding)

对象头：分两类信息
1. 第一类信息用与存储对象自身的运行时数据,如 哈希码 GC分带年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳。官方称为"Mark Word"。32位虚拟机中mark word占32位，64位占64位
2. 第二类信息是类型指针。此外如果是数组对象必须有一块用于记录数组长度。

实例数据：  
实例数据中包含自己与父类的实例数据，分配的顺序受 `-XX:FieldsAllocationStyle` 参数和定义的顺序影响。Hotspot默认顺序：longs/doubles ints shorts/chars bytes/booleans oops，宽度相同的总是被分配到一起。在这个条件下，父类的参数总是在子类之前，但参数 `+XX:CompactFields` 为true时(默认为ture)子类中较窄的变量也运行插入父类变量的空隙中。  

对齐填充：  
HostSpot虚拟机要求对象起始地址必须是8字节的整数倍。换句话说就是对象大小必须是8字节的整数被，不足则会填充。

#### 2.3.3 对象的访问定位

由栈上的reference类型访问对象。主流的访问方式主要有 “句柄” 和 “直接指针” 两种。  

句柄访问：
<div align="center"><img src="/image/readbook/1.png"/></div>

直接指针：
<div align="center"><img src="/image/readbook/2.png"/></div>

优缺点：句柄访问在内存频繁移动时，不需要大量修改reference地址，只要修改句柄上的对象地址，但是访问速度慢。而指针访问速度快，但对象移动时，所有指向这个对象的reference地址都需要改动。Hotspot使用的是直接指针(如果使用的Shenandoah收集器的话也会有一次额外的转发)。

### 2.4 实战OutOfMemoryError异常

#### 2.4.1 Java堆溢出

详见代码readbook.c241

> VM Args: -Xms20m(最小堆内存) -Xmx20m(最大堆内存)  
  +HeapDumpOnOutOfMemoryError(Dump内存堆快照)  

#### 2.4.2 虚拟机栈和本地方法栈溢出

> -Xoss 设置本地方栈的大小 对Hotspot没有意义  
  -Xss 设置栈容量 Hotspot栈不可扩容不能设置最大值

#### 2.4.3  方法区和运行时常量池溢出

> -XX:MaxMetaspaceSize 元空间最大容量 默认-1 即不限制 或只受限于本地内存   
  -XX:MetaspaceSize 元空间初始容量 当达到该值时就会GC 并根据需要修改容量 但不超过设置的最大值  
  -XX:MaxMetaspaceFreeRatio 调整GC后最小元空间剩余容量的百分比  
  -XX:MinMetaspaceFreeRatio 最大元空间剩余容量的百分比

在1.7之后 String常量池放在堆内存中

```java
    /**
    *  在1.6前会打印两个false 
    *  因为 StringBuild创建的String对象在堆中 str1.intern() 对象放在了方法区中
    *  而在1.7之后会打印一个true 一个false 
    *  打印true是因为 intern() 放入String常量池中 而String常量池已经移到了堆上
    *  而打印false是因为sun.misc.Version类加载时就将java放入了String常量池(堆)
    *  StringBuild创建的就是另一个对上的对象了
    */
    public class RuntimeConstantPool {
        
        public static void main(String args[]) {
            String str1 = new StringBuilder("计算机").append("软件").toString();
            System.out.println(str1.intern() == str1); // 1.6 false 1.7 true
                        
            String str1 = new StringBuilder("ja").append("va").toString();
            System.out.println(str1.intern() == str1);// 1.6 false 1.7 false
        }
        
    }
    
```
#### 2.4.4 本机直接内存溢出

> -XX:MaxDirectMemorySize 最大直接内存 默认值与java堆一致(-Xmx的值)

如果使用了DirectMemory的程序需要注意(比如NIO DirectByteBuffer)

### 2.5 本章小结

略....(请看上面的笔记)

## 第3章 垃圾收集器与内存分配策略

### 3.1 概述

略....

### 3.2 对象已死

#### 3.2.1 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。  
优缺点：实现简单，相互引用就会产生内存泄露

#### 3.2.2 可达性分析法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GCRoots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
<div align="center"><img src="/image/readbook/3.jpg"/></div>

GCRoots对象：
1. 在虚拟机栈(本地变量表)中引用的对象
2. 在方法区中类静态属性引用的对象
3. 在方法区中常量引用的对象
4. 在本地方法栈中JNI(Native方法)引用的对象
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象 一些常驻的异常对象(NullPoint,OOM),还有系统类加载器
6. 所有被同步锁(synchronized关键字)持有的对象
7. 反映Java虚拟机部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

#### 3.2.3 再谈引用

引用分为:
1. 强引用(Strongly Reference):  
   指在程序代码之中普遍存在的引用赋值，类似`Object obj = new Object()` 只要强引用关系还存在，垃圾收集器就永远不会回收。
2. 软引用(Soft Reference):  
   描述非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。JDK 1.2版之后提供了SoftReference类来实现软引用。
3. 弱引用(Weak Reference):  
   被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
4. 虚引用（PhantomReference）  
   虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。
   这4种引用强度依次逐渐减弱。

#### 3.2.4 生存还是死亡

经过可达性分析后被标记的对象并不会马上死亡，GC系统会筛选出此对象是否必要执行finalize()方法。如果对象没有重写，或已经被调用过一次(每个对象虚拟机只会调用一次finalize()方法)，虚拟机就判断不再需要执行，进入"即将回收"的集合。如果重写了没有执行过，则会进入F-Queue队列让一个低调用线程去执行(但并不保证可以直接结束)。如果在执行方法时，this对象被重新引用，对象就不会被销毁，反之则进入"即将回收"的集合。

#### 3.2.5 回收方法区

废弃的常量：  
没有任何引用，垃圾收集器判断有必要的话会被回收。  

不再使用的类型：
判定是否废弃的类型需要满足3个条件：
1. 该类所有实例(包括派生类)被回收
2. 该类的类加载器被回收
3. 该类的Class对象没有任何引用  

满足以上3个条件也仅仅是"允许被回收"

> -Xnoclasscg 参数控制是否有类回收

有大量的反射，动态代理，CGLib等字节码框架，动态生成Jsp以及OGSi这类频繁自定义类加载器的场景中需要开启。

### 3.3 垃圾回收算法

#### 3.3.1 分代收集理论

* 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
* 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
* 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
* 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
* 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

#### 3.3.2 标记-清除算法

标记需要回收的对象/不需要回收的对象，清楚被标记/未被标记的对象。  
缺点：效率不稳定，空间碎片化

#### 3.3.2 标记-复制算法

"半区复制" 即 `To Survivor` `From Survivor`  
优缺点：空间连续，浪费了一定空间，只适合存活对象不多的区域。所以用于新生代回收算法。 
Eden与Survivor 比例 8:1:1

#### 3.3.3 标记-整理算法

即在标记清除上多做一次整理，让内存空间不在有碎片。  
HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的

### 3.4 HotSpot的算法细节实现

#### 3.4.1 根节点枚举

固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中  

所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。

#### 3.4.2 安全点

HotSpot没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）。  

安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的。例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。  

如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：
1. 抢先式中断（Preemptive Suspension）：系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。
2. 主动式中断（Voluntary Suspension）：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。  
   由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。  

#### 3.4.3 安全区域

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。  

当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

#### 3.4.4 记忆集和卡表

所有涉及部分区域收集行为的垃圾收集器都会面临对象跨代引用所带来的问题。解决方案就是依靠记忆集。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

记忆集的的记录精度：
* 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
* 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
* 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式。卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的。  
  字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即512字节。
  一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

#### 3.4.5 写屏障

HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。  应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作。  

伪共享：现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。

> HotSpot虚拟机增加了一个新的参数 -XX：+UseCondCardMark ，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。

#### 3.4.6 并发的可达性分析

三色标记:
* 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
* 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
* 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。  

如果用户线程与收集器是并发工作，收集器在对象图上标记颜色，同时用户线程在修改引用关系，可能出现两种后果：
1. 把原本消亡的对象错误标记为存活。可以容忍。
2. 原本存活的对象错误标记为已消亡。非常致命。

例图：
<div align="center"><img src="/image/readbook/4.jpg"/></div>

Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题(2问题)，即原本应该是黑色的对象被误标为白色：
* 赋值器插入了一条或多条从黑色对象到白色对象的新引用。
* 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：
1. 增量更新（Incremental Update）:  
   增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，`黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了`。

2. 原始快照（Snapshot At TheBeginning，SATB）:
   原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，`无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索`。

### 3.5 经典垃圾回收器

这里讨论的是在JDK 7Update 4之后（在这个版本中正式提供了商用的G1收集器，此前G1仍处于实验状态）、JDK11正式发布之前，OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。

<div align="center"><img src="/image/readbook/5.jpg"/></div>

上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。


#### 3.5.1 Serial收集器

曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择，这个收集器是一个单线程工作的收集器。强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。  

它是所有收集器里额外内存消耗（Memory Footprint）最小的。

#### 3.5.2 ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：`-XX：SurvivorRatio(设置eden占n/10 默认8)、-XX：PretenureSizeThreshold(设置超过n大小直接在old区分配 默认0 优先eden分配)、-XX：HandlePromotionFailure`等）、收集算法、Stop TheWorld、对象分配规则、回收策略等都与Serial收集器完全一致。  

ParNew/Serial Old 收集器运行示意图:
<div align="center"><img src="/image/readbook/6.jpg"/></div>

#### 3.5.3 Parallel Scavenge收集器

Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似。

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。`吞吐量 = 运行时代码时间/运行时代码时间 + 运行垃圾收集时间`  

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量:
1. 控制最大垃圾收集停顿时间的 `-XX：MaxGCPauseMillis`：  
   允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。
2. 设置吞吐量大小的参数 `-XX：GCTimeRatio` ：  
   参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。(`N:1` N 即设置的值 如19 吞吐量 = 1/(19+1) 如99 吞吐量 = 1/(99+1) 默认值为99)  
   
Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得我们关注：`-XX：+UseAdaptiveSizePolicy`：  
这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。  
只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX：MaxGCPauseMillis参数（更关注最大停顿时间）或-XX：GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标。自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。

#### 3.5.4 Serial Old收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。

Serial/Serial Old 收集器运行示意图:
<div align="center"><img src="/image/readbook/7.jpg"/></div>

#### 3.5.5 Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

Parallel/Parallel Old 收集器运行示意图: 注*这是jdk1.8默认收集器组合!
<div align="center"><img src="/image/readbook/8.jpg"/></div>

#### 3.5.6 CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。是基于标记-清除算法实现的。

它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：
1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）  

初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。  

Concurrent Mark Sweep 收集器运行示意图:
<div align="center"><img src="/image/readbook/9.jpg"/></div>

#### 3.5.7 Garbage First收集器

Garbage First（简称G1）收集器是面向局部收集的设计思路和基于Region的内存布局形式。  

G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。  

Region中还有一类特殊的Humongous区域，专门用来存储大对象。可以通过参数`-XX：G1HeapRegionSize`设定。G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。  

G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，根据用户设定允许的收集停顿时间（使用参数`-XX：MaxGCPauseMillis`指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region。  

G1收集器Region分区示意图：
<div align="center"><img src="/image/readbook/10.jpg"/></div>

解决跨Region引用：每个Region都维护有自己的记忆集，G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。通过原始快照（SATB）算法来实现收集线程与用户线程互不干扰。  

的运作过程大致可划分为以下四个步骤：
1. 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象。这个阶段需要停顿线程。
2. 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析。
3. 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
4. 筛选回收（Live Data Counting and Evacuation）：根据用户所期望的停顿时间来制定回收计划。必须暂停用户线程，由多条收集器线程并行完成的。  

G1收集器运行示意图：
<div align="center"><img src="/image/readbook/11.jpg"/></div>

`-XX：MaxGCPauseMillis`：允许的收集停顿时间，默认值是200毫秒。

### 3.6 低延迟垃圾收集器

衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency）  

下图，中浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。

<div align="center"><img src="/image/readbook/12.jpg"/></div>

可见，在CMS和G1之前的全部收集器，其工作的所有步骤都会产生“Stop TheWorld”式的停顿；CMS和G1分别使用增量更新和原始快照（见3.4.6节）技术，实现了标记阶段的并发，不会因管理的堆内存变大，要标记的对象变多而导致停顿时间随之增长。但是对于标记阶段之后的处理，仍未得到妥善解决。CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop The World”的命运。G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，但毕竟也还是要暂停的。  
最后的两款收集器，Shenandoah和ZGC，几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定的，与堆的容量、堆中对象的数量没有正比例关系。被官方命名为“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time GarbageCollector）。

#### 3.6.1 Shenandoah收集器

Shenandoah是由RedHat公司独立发展的新型收集器项目。Shenandoah像是G1的下一代继承者。它们两者有着相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路上都高度一致，甚至还直接共享了一部分实现代码。  
Shenandoah相较G1的改进，虽然Shenandoah也是使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region……但在管理堆内存方面，它与G1至少有三个明显的不同之处：
1. 最重要的当然是支持并发的整理算法。
2. Shenandoah（目前）是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在。
3. Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系。降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题。

Shenandoah收集器的工作过程大致可以划分为以下九个阶段：
1. 初始标记（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。
2. 并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。
3. 最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。
4. 并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。
5. 并发回收（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。并发回收阶段运行的时间长短取决于回收集的大小。
6. 初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。
7. 并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。
8. 最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GCRoots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。
9. 并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。  

Shenandoah收集器的工作过程图
<div align="center"><img src="/image/readbook/12.jpg"/></div>

Shenandoah用以支持并行整理的核心概念——Brooks Pointer：转发指针  
在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。与句柄定位有一些相似之处，柄通常会统一存储在专门的句柄池中，而转发指针是分散存放在每一个对象头前面。  

转发指针与并发写入：（并发读取无论是新对象还是就对象都是一致的）
通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。

#### 3.6.2 ZGC收集器

ZGC内存布局：  
与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局，但与它们不同的是，ZGC的Region。ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。在x64硬件平台下，ZGC的Region可以具有大、中、小三类容量：
1. 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
2. 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。
3. 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。

并发整理算法的实现：TODO

### 3.7 选择适合的垃圾收集器

#### 3.7.1 Epsilon收集器

#### 3.7.2 收集器的权衡

一般来说，收集器的选择就从以上这几点出发来考虑：
1. 应用程序的主要关注点是什么？如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点；如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。  
2. 运行应用的基础设施如何？譬如硬件规格，要涉及的系统架构是x86-32/64、SPARC还是ARM/Aarch64；处理器的数量多少，分配内存的大小；选择的操作系统是Linux、Solaris还是Windows等。  
3. 使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？

#### 3.7.3 虚拟机及垃圾收集器日志

1. 查看GC基本信息，在JDK 9之前使用-XX：+PrintGC，JDK 9后使用-Xlog：gc：
2. 查看GC详细信息，在JDK 9之前使用-XX：+PrintGCDetails，在JDK 9之后使用-X-log：gc*，用通配符*将GC标签下所有细分过程都打印出来，如果把日志级别调整到Debug或者Trace（基于版面篇幅考虑，例子中并没有），还将获得更多细节信息
3. 查看GC前后的堆、方法区可用容量变化，在JDK 9之前使用-XX：+PrintHeapAtGC，JDK 9之后使用-Xlog：gc+heap=debug：
4. 查看GC过程中用户线程并发时间以及停顿的时间，在JDK 9之前使用-XX：+Print-GCApplicationConcurrentTime以及-XX：+PrintGCApplicationStoppedTime，JDK 9之后使用-Xlog：safepoint：
5. 查看收集器Ergonomics机制（自动设置堆空间各分代区域大小、收集目标等内容，从Parallel收集器开始支持）自动调节的相关信息。在JDK 9之前使用-XX：+PrintAdaptive-SizePolicy，JDK 9之后使用-Xlog：gc+ergo*=trace：
6. 查看熬过收集后剩余对象的年龄分布信息，在JDK 9前使用-XX：+PrintTenuring-Distribution，JDK 9之后使用-Xlog：gc+age=trace：

下图给出了全部在JDK 9中被废弃的日志相关参数及它们在JDK9后使用-Xlog的代替配置形式。
<div align="center"><img src="/image/readbook/14.png"/></div>

#### 3.7.4 垃圾收集器参数总结

<div align="center"><img src="/image/readbook/15.png"/></div>

### 3.8 实战：内存分配与回收策略

#### 3.8.1 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

#### 3.8.2 大对象直接进入老年代

大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。  
在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。  
HotSpot虚拟机提供了`-XX：PretenureSizeThreshold`参数，指定大于该设置值的对象直接在老年代分配。(只对Serial和ParNew两款新生代收集器有效)

#### 3.8.3 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15，最大也为15，因为分代年龄只占1byte 4个bit位，最大值就是15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数`-XX：MaxTenuringThreshold`设置。

#### 3.8.4 动态对象年龄判断

HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。

#### 3.8.5 空间分配担保

在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次FullGC。  
实际虚拟机中已经不会再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。

### 3.9 本章小结

略....

## 第4章 虚拟机性能监控、故障处理工具



































